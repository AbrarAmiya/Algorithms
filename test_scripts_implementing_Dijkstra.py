# -*- coding: utf-8 -*-
"""Task 1 Test case.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RufjA4GKB60M3sMTNZikSjlCBGlNTfJS
"""

def Djkstra(source, matrix):
  distance = [99999,99999,99999,99999,99999,99999,99999]
  parent = [None,None,None,None,None,None]
  Queue = []
  neighbourV = [[0],[2,3,4],[4,5],[5],[3],[4]]
  counter = 1
  # for i in range(len(matrix)):
  #   for j in matrix[i]:
  #     if j!=0:
  #       neighbourV[counter] = j
  #       counter+=1

  # return neighbourV
  track = []
  for i in range(len(neighbourV)):
    arr=[]
    for j in neighbourV[i]:
      arr.append(matrix[i][j])

    Queue.append(arr)

  #extracting minimum

  for v in range(len(neighbourV)):
    disV=0
    for n in range(len(neighbourV[v])):

      if distance[v]>disV+Queue[v][n]:
        distance[v]=disV+Queue[v][n]
  return distance, Queue


#driver code
matrix = [
    [0,0,0,0,0,0],
    [0,0,5,7,2,0],
    [0,0,0,0,3,4],
    [0,0,0,0,0,8],
    [0,0,0,2,0,0],
    [0,0,0,0,10,0]

]
vertex = [1,2,3,4,5]
source = 1
print(Djkstra(source,matrix))

def Dijkstra(source, matrix, N):
    distance = [99999,99999,99999,99999,99999]
    distance[source - 1] = 0
    parent = [None] * N
    visited = [False] * N

    for _ in range(N):
        min_distance = 99999
        min_vertex = -1

        for v in range(N):
            if not visited[v] and distance[v] < min_distance:
                min_distance = distance[v]
                min_vertex = v

        if min_vertex == -1:
            break

        visited[min_vertex] = True

        for v in range(N):
            if matrix[min_vertex][v] != 0:
                new_distance = distance[min_vertex] + matrix[min_vertex][v]
                if new_distance < distance[v]:
                    distance[v] = new_distance
                    parent[v] = min_vertex


    for i in range(len(distance)):
        if distance[i] == 99999:
            distance[i] = -1

    return distance, parent, visited


# Driver code
matrix = [
    [0, 5, 7, 2, 0],
    [0, 0, 0, 3, 4],
    [0, 0, 0, 0, 8],
    [0, 0, 2, 0, 0],
    [0, 0, 0, 10, 0]
]
source = 1
N = 5
print(Dijkstra(source, matrix, N))

def Dijkstra(G, s):
    def extract_min(Q, d):
        min_val = float('inf')
        min_vertex = None
        for v in Q:
            if d[v] < min_val:
                min_val = d[v]
                min_vertex = v
        return min_vertex

    V = list(G.keys())
    d = {v: float('inf') for v in V}
    d[s] = 0
    S = set()
    Q = set(V)

    while Q:
        u = extract_min(Q, d)
        if u is None:
            break
        Q.remove(u)
        S.add(u)

        for v in G.get(u, {}):
            if v in Q:
                new_distance = d[u] + G[u][v]
                if new_distance < d[v]:
                    d[v] = new_distance

    # Convert infinite distances to -1 as required
    for v in V:
        if d[v] == float('inf'):
            d[v] = -1

    return d


# Driver code
matrix = {
    1: {2: 5, 3: 7, 4: 2},
    2: {4: 3, 5: 4},
    3: {5: 8},
    4: {3: 2},
    5: {4: 10}
}

matrix_2 = {
    1: {2: 3, 3: 6},
    3: {4: 2},
    4: {5: 2},
    5: {1: 1, 2: 10},
    2: {6: 2, 3: 10}
}


source = 1
distances = Dijkstra(matrix, source)
output = " ".join(str(distances[v]) for v in distances)
print(output)

source_2 = 1
distances2 = Dijkstra(matrix_2, source_2)
output2 = " ".join(str(distances2[v]) for v in distances2)
print(output2)

def Dijkstra(source, matrix, N):
    distance = [99999] * N
    distance[source - 1] = 0
    parent = [None] * N
    visited = [False] * N

    for _ in range(N):
        min_distance = 99999
        min_vertex = -1

        for v in range(N):
            if not visited[v] and distance[v] < min_distance:
                min_distance = distance[v]
                min_vertex = v

        if min_vertex == -1:
            break

        visited[min_vertex] = True

        for v in range(N):
            if matrix.get(min_vertex + 1) and matrix[min_vertex + 1].get(v + 1):
                new_distance = distance[min_vertex] + matrix[min_vertex + 1][v + 1]
                if new_distance < distance[v]:
                    distance[v] = new_distance
                    parent[v] = min_vertex

    for i in range(len(distance)):
        if distance[i] == 99999:
            distance[i] = -1

    return distance


# Corrected graph representation
matrix_2 = {
    1: {2: 3, 3: 6},
    3: {4: 2},
    4: {5: 2},
    5: {2: 10, 1: 1},
    6: {2: 2, 3: 10}
}

source_2 = 1
distances2 = Dijkstra(source_2, matrix_2, 6)
output2 = " ".join(str(distances2[v - 1]) for v in range(1, 7))
print(output2)

# -*- coding: utf-8 -*-
"""Lab06_Task1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Px44HOweyenIxXgtoAdmIn7TJ9-qW5Hk

### TASK **1**
"""

def dijkstra(adj_list, start_node):


    # Initialize the distances to all nodes as infinity except the start node
    num_nodes = len(adj_list)
    dist = [-1] * num_nodes
    dist[start_node] = 0

    # Initialize the priority queue with the start node
    p_queue = [(0, start_node)]

    while p_queue:
        # To Get the node with the smallest distance from the priority queue
        (cur_dist, cur_node) = min(p_queue)

        # Remove the node from the priority queue
        p_queue.remove((cur_dist, cur_node))

        # If the node has already been processed, continue
        if cur_dist != dist[cur_node]:
            continue

        # Update the distances to the adjacent nodes
        for (adj_node, weight) in adj_list[cur_node]:
            new_dist = cur_dist + weight

            if dist[adj_node] == -1 or new_dist < dist[adj_node]:
                dist[adj_node] = new_dist
                p_queue.append((new_dist, adj_node))

    return dist


if __name__ == '__main__':
    # Read input from file
    with open('/content/Input1.txt', 'r') as f:
        n, m = map(int, f.readline().split())
        adj_list = [[] for _ in range(n)]
        for i in range(m):
            u, v, w = map(int, f.readline().split())
            adj_list[u - 1].append((v - 1, w))
        start_node = int(f.readline())

    # Compute shortest distances using Dijkstra's algorithm
    dist = dijkstra(adj_list, start_node - 1)

    # Write output to file
    with open('/content/Output1.txt', 'w') as f:
        for d in dist:
            f.write(str(d) + ' ')