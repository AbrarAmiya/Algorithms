# -*- coding: utf-8 -*-
"""Alien Count with Divide.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1b5gii9FyECH4xTVbe0D2qBQHtJISs4vr
"""

n = 5
arr = [5,4,3,2,1]
count = 0

for i in range(n):
  for j in range(i+1, n):
    if arr[i]>arr[j]:
      count+=1

print(count)

def merge(arr, temp, left, mid, right):
    i = left  # Index for the left subarray
    j = mid + 1  # Index for the right subarray
    k = left  # Index for the merged subarray
    count = 0  # Counter for the number of inversions

    while i <= mid and j <= right:
        if arr[i] <= arr[j]:
            temp[k] = arr[i]
            i += 1
        else:
            temp[k] = arr[j]
            count += mid - i + 1  # Increment count when there is an inversion
            j += 1
        k += 1

    # Copy the remaining elements of the left subarray, if any
    while i <= mid:
        temp[k] = arr[i]
        i += 1
        k += 1

    # Copy the remaining elements of the right subarray, if any
    while j <= right:
        temp[k] = arr[j]
        j += 1
        k += 1

    # Copy the merged elements back to the original array
    for x in range(left, right + 1):
        arr[x] = temp[x]

    return count


def mergeSort(arr, temp, left, right):
    count = 0

    if left < right:
        mid = (left + right) // 2

        # Recursively sort the left and right subarrays
        count += mergeSort(arr, temp, left, mid)
        count += mergeSort(arr, temp, mid + 1, right)

        # Merge the sorted subarrays and count inversions
        count += merge(arr, temp, left, mid, right)

    return count


n = 5
arr = [5, 4, 3, 2, 1]
temp = [0] * n  # Temporary array for merging
count = mergeSort(arr, temp, 0, n - 1)
print(count)

def merge(arr1, arr2, count):
    merged_arr = []
    current_count = count
    i = j = 0

    while i < len(arr1) and j < len(arr2):
        if arr1[i] > arr2[j]:
            merged_arr.append(arr2[j])
            current_count += len(arr1) - i
            j += 1
        else:
            merged_arr.append(arr1[i])
            i += 1

    merged_arr.extend(arr1[i:])
    merged_arr.extend(arr2[j:])

    return merged_arr, current_count


def AlienCount(arr, count=0):
    if len(arr) == 1:
        return arr, count

    mid = len(arr) // 2
    x, c1 = AlienCount(arr[:mid], count)
    y, c2 = AlienCount(arr[mid:], count)

    merged_arr, current_count = merge(x, y, c1 + c2)

    return merged_arr, current_count


# Example usage
n = 8
arr = [2,7,4,1,5,6,8,3]
sorted_arr, count = AlienCount(arr)
print(count)

def merge(arr1, arr2, count):
    # Initialize an empty array to store the merged elements
    merged_arr = []
    # Initialize a variable to keep track of the current count
    current_count = count
    # Initialize two pointers for traversing arr1 and arr2
    i = j = 0

    # Merge the elements of arr1 and arr2 while updating the count
    while i < len(arr1) and j < len(arr2):
        if arr1[i] > arr2[j]:
            # If an element in arr1 is greater than arr2, append arr2[j] to the merged array
            merged_arr.append(arr2[j])
            # Update the count by adding the number of elements remaining in arr1
            current_count += len(arr1) - i
            # Move the pointer j to the next element in arr2
            j += 1
        else:
            # If an element in arr1 is less than or equal to arr2, append arr1[i] to the merged array
            merged_arr.append(arr1[i])
            # Move the pointer i to the next element in arr1
            i += 1

    # Add the remaining elements of arr1 to the merged array
    merged_arr.extend(arr1[i:])
    # Add the remaining elements of arr2 to the merged array
    merged_arr.extend(arr2[j:])

    # Return the merged array and the current count
    return merged_arr, current_count

def AlienCount(arr, count=0):
    # Base case: If the length of arr is 1, return arr and the count
    if len(arr) == 1:
        return arr, count

    # Find the midpoint of arr
    mid = len(arr) // 2

    # Recursively call AlienCount on the left half of arr
    x, c1 = AlienCount(arr[:mid], count)
    # Recursively call AlienCount on the right half of arr
    y, c2 = AlienCount(arr[mid:], count)

    # Merge the results from the left and right halves
    merged_arr, current_count = merge(x, y, c1 + c2)

    # Return the merged array and the updated count
    return merged_arr, current_count

# Example usage
n = 8
arr = [2, 7, 4, 1, 5, 6, 8, 3]
# Call AlienCount to calculate the count of pairs satisfying the condition
sorted_arr, count = AlienCount(arr)
# Print the count
print(count)